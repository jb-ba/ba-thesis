\subsubsection{Resource consumption}
Memory consumption from containers is always greater than bare metal deployments. By design containers share little with the default namespace, apart from system resources, like the kernel. It is possible to give containers access to host directories, but this often breaks their design philosophy of being stateless and portable. The solution is to include the libraries, tools, certificates necessary to run the application in the container itself. It is not hard to image with multiple containers memory and RAM consumption can easily exceed the system resources of edge devices, e.g. the Raspberry Piâ€™s. For example, deploying the latest official openJDK container consumes 470MB. Source and byte code and dependencies add on top of this. Compiled language are at a huge advantage in this regard. Go is one such example and used in this thesis. It can be cross-compiled to machine code for most CPU architecture compatible with Linux and results in one application file without any dependencies. Multi-stage builds allow to have one container to build the application and only copy relevant files into the final image. This eliminates any unused files and is often used in combination with the \textit{scratch} image. This is the base image for all other containers and is basically an empty file structure consuming no memory. According to Docker it ``is most useful in the context of building [...] super minimal images''\cite{scratchImageDockerD65:online}.\\
Combining these these techniques can result in far lower memory and RAM consumption, but also better security (discussed in the next section). In the implementation, \cref{sec:testService} \nameref{sec:testService}