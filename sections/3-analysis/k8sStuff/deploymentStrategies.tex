\subsubsection{Deployment Strategies}
\comment{
deployment vs statefulset vs daemonset
clusterIP vs nodeport
Taints, nodeselector, affinities pod/node
namespaces
}

The \textit{service} resource provides an abstraction between the network interface and the actual application. From an outsiders view, it is possible to call the Kubernetes ingress gateway under a subsection and get to a pod running somewhere in the cluster without knowing its specific address. This is the usual deployment strategy for stateless applications. The pod have a \textit{clusterIP} rendering it only accessible from inside the cluster. However, this makes little sense for the edge, where latency is key and an Internet connection is not guaranteed. Instead, it is possible to define a \textit{nodePort} inside a service so that all its pods expose a certain port on the host node. Other services can now connect directly to the pod and the container listing for incoming connections.\\
Kubernetes also offers different resources for core workloads, \textit{Deployments},  \textit{StatefulSets},  \textit{DaemonSets} and  \textit{ReplicationController}, which should not be used anymore\cite{CoreWorkloadKubernetes66:online}. They all describe a desired state and Kubernetes controller works towards fulfilling the desired state. Deployments are mainly used for stateless services. StatefulSets are used for stateful services and DaemonSets are to deploy pods on each node. For the edge all workloads are important, but it is important to choose the correct workload for a desired result even more so than in the cloud. Because of the resource limitations of edge devices auto-scaling is not possible and devices can get quickly overwhelmed by too tasks. This also puts an emphasis on the prioritization of workloads in case the computing resources are not enough for all workloads.\\
Kubernetes offers powerful concepts to achieve the correct scheduling of pods. They are \textit{nodeSelector}, \textit{taints}, \textit{tollerations}, \textit{affinities} and \textit{anti-affinities}. A NodeSelector specifies which tags have to be present on a node for a pod to be scheduled on. Taints are added to nodes and specifies that only pods with the matching tolleration can run on the node. For exmaple, the master has the taint \textit{NoSchedule} which means, only pods with the matching tolleration can be scheduled on a the master. Finally, affinities and anti-affinities, offer a way for pods to be scheduled (or not) on either pods or nodes with a specific tag. This gives operators the ability to add workloads only on nodes which are already running another service, or with anit-affinity, where a pod is not present. Again, these are very powerful tools and have to be selected carefully.\\
Finally, \textit{namespaces} offer the ability to separate one physical cluster into mulitple virtual clusters. Most Kubernetes resources are saved inside namespaces and are especially important in a single-cluster setup with multiple user groups. Administrators can define namespaces and assign them resource limits as well as nodes via the \textit{PodNodeSelector}. This makes it possible to assign each edge deployment a virtual cluster and developers can only modify resources within that namespace. It is also possible to define role-based access control (RBAC) to limit what a specific user or user group can modify inside the namespace. 
