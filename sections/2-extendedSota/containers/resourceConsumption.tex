% \subsubsection{Resource consumption}
Processing power consumption from containers is always greater than bare metal deployments. However, recent research has shown that in most cases this is almost negligible. In an updated performance assessments of containers the authors found that containers introduce almost no overhead over a native deployment\cite{felter2015updatedPerformanceContainers}. By design containers share little with the default namespace, apart from system resources, like the kernel. It is possible to give containers access to host directories, but this often breaks their design philosophy of being stateless and portable. The solution is to include the libraries, tools, certificates necessary to run the application in the container itself. This can potentially lead to a ballooning size of containers and with multiple containers running simultaneously, disk space and memory consumption can easily exceed the system resources of an edge devices. E.g. deploying the latest official openJDK container consumes 470MB and only includes the runtime dependency for the JVM. Source and byte code and dependencies of the application would all add extra disk space on top of this. Compiled language are at a huge advantage in this regard. They compile to machine code and include all code dependencies in one binary. Some compiled languages even offer the possibility of cross-compilation. This means source code can be compiled for a different architecture they are being compiled on. This allows servers running on the x86 or amd64 architecture to compile to native ARM machine code.

Additionally, containers allow and encourage multi-stage builds. This method of building containers allows to have one container to build the application and another one to run the application. The one used for building contains all dependencies and the compile environment, while the one used for running the application only contains the binary and run-time relevant files (e.g. certificates or the linux user). This eliminates any unused files and is often used in combination with the \textit{scratch} image. 

It is the base image for all other images and is basically an empty file structure consuming no disk space or memory\footnote{It also creates an isolated network and process namespace, but they are also very cheap.}. According to Docker the scratch image ``is most useful in the context of building [...] super minimal images''\cite{scratchImageDockerD65:online}. Another advantage using smaller images is the faster extracting time. Images are usually stored as archives and extracted on the host machine placing an additional strain on the system for each new deployment.\\[0.5mm]
\comment{
Combining these these techniques can result in far lower memory and RAM consumption, but also better security (discussed in the next section). In the implementation, \cref{sec:testService} \nameref{sec:testService}, I will show just how much memory can be saved using these techniques. 




In an updated performance assessments of containers the authors found that containers introduce almost no overhead over a native deployment\cite{felter2015updatedPerformanceContainers}. Hence, gateways running Linux can in most cases use containers without a problem. 
}